#!/bin/bash

#----
#Version: 0.1a
#Author: Axel Philippe-Jolivel
#Modified: 21/04/2021
#----

#Global program help
sub_help(){
printf "%s\n" "Usage: livescore [COMMAND] [ARGUMENT]" \
" " \
"This script checks for today's US sports games using the ESPN API." \
" " \
"Commands:" \
"	planning		Shows games played today." \
"	live (not yet implemented)" \
" " \
"Arguments:" \
"	planning: [nba,nhl,mlb,all]" \
"	live: (not yet implemented)" \

}

#Planning subCommand
sub_planning(){
local argument
local sports="nba nhl mlb"
argument=$1
case "${argument}" in
    "help" | "")
        printf '%s\n' 'sub command help'
        ;;
    "all")
		printf "%s%s%s" "${argument^^}" " upcoming games"
		echo -e "\n"
		for sport in $sports; do
			icon="${sport}_icon"
			printf "%s\n" "${!icon} ------${sport^^}------- ${!icon}"
			planning_api_call "${sport}"
			if [ ! -z "${matchArray}" ]; then
				for ((i=0;i<=${#matchArray[@]}/2;i+=2)); do
					planning_printer "$i"
				done
			fi
			echo -e "\n"
		done
        ;;
	"nba" | "mlb" | "nhl" | "nfl")
		printf "%s%s%s" "${argument^^}" " upcoming games"
		echo -e "\n"
		icon="${argument}_icon"
		printf "%s\n" "${!icon} ------${argument^^}------- ${!icon}"
		planning_api_call ${argument}
		if [ ! -z "${matchArray}" ]; then
			for ((i=0;i<=${#matchArray[@]}/2;i+=2)); do
				planning_printer "$i"
			done
		fi
		;;
esac
}

# API Call -> json decode with jq -> bash array $matchArray
# Array template : [Match#1] [Date#1] [Match#2] [Date#2] [Match#n] [Date#n]
# Works with current date only in v0.1, support for future date input in roadmap, support for multiple date input in roadmap
planning_api_call(){
	local sport=""
	local date=$(date +"%Y%m%d")
	case "$1" in
		"nba")
		sport="basketball/nba"
		;;
		"nhl")
		sport="hockey/nhl"
		;;
		"mlb")
		sport="baseball/mlb"
		;;
		"nfl")
		sport="football/nfl"
		date="$(date +"%Y%m%d")-$(date +"%Y%m%d" --date='next sunday')"
		;;
	esac
	local url="http://site.api.espn.com/apis/site/v2/sports/${sport}/scoreboard?dates=${date}"
	local wgetResult=$(wget -qO- "${url}")
	local jqOut=$(echo "${wgetResult}" | jq -c '.events[] | .name,.date')
	if [ -z "${jqOut}" ]; then
		echo "No games found for this date"
	else
		local IFS=$'\n'
		matchArray=( $( printf "%s\n" "${jqOut//[\"\"]}" ) )
	fi
}

# Pretty print of $matchArray from API Call
planning_printer(){
	local match=${matchArray[$1]}
	local IFS=$';'
	local specificMatchArray=( ${match// at/\;} )
	local IFS=$' \t\n'
	local team1=${specificMatchArray[0]}
	local team2=${specificMatchArray[1]/ /}
	local color1=$(get_team_color "${team1}")
	local color2=$(get_team_color "${team2}")
	local date=${matchArray[(($1+1))]}
	local dateNotUTC=$(date -d "TZ=\"UTC\" $date" +"%T %A %d" )
	printf "%s\n" "${!color1}${team1}${end} @ ${!color2}${team2}${end} | ${dateNotUTC}"
	printf "%s\n" ""
}


sub_results(){
local argument
argument=$1
case "${argument}" in
    "help" | "")
        printf '%s\n' 'sub command help'
        ;;
	"football")
		printf "%s%s%s" "${argument^^}" " last results"
		echo -e "\n"
		icon="${argument}_icon"
		printf "%s\n" "${!icon} ------${argument^^}------- ${!icon}"
		for comp in ${COMPETITIONS[@]}; do
			results_football_api_call ${comp}
			if [ ! -z "${matchArray}" ]; then
				for ((i=0;i<${#matchArray[@]}/5;i+=1)); do
					results_printer "$i"
				done
			fi
		done
		;;
esac
}

# API Call -> json decode with jq -> bash array $matchArray
# Array template : [HomeTeam] [AwayTeal] [Date] [homeScore] [awayScore]...
results_football_api_call(){
	local sport=""
	local date=$(date +"%Y%m%d")
	# $(date +"%Y%m%d" --date='next sunday')
	local url="http://api.football-data.org/v4/competitions/$1/matches?dateFrom=2024-03-16&dateTo=2024-03-17"
	local wgetResult=$(wget -qO- "${url}" --header='X-Auth-Token: 591daf1a01f746978343ba83a101fc19')
	local jqOut=$(echo "${wgetResult}" | jq -c '.matches[] | .homeTeam.shortName,.awayTeam.shortName,.utcDate,.score.fullTime.home,.score.fullTime.away')
	if [ -z "${jqOut}" ]; then
		echo "No games found for this date"
	else
		local IFS=$'\n'
		matchArray=( $( printf "%s\n" "${jqOut//[\"\"]}" ) )
	fi
}

results_printer(){
	local team1=${matchArray[(($1*5))]}
	local team2=${matchArray[(($1*5+1))]}
	#local color1=$(get_team_color "${team1}")
	#local color2=$(get_team_color "${team2}")
	local date=${matchArray[(($1*5+2))]}
	local dateNotUTC=$(date -d "TZ=\"UTC\" $date" +"%T %A %d" )
	printf "%s\n" "${team1} ${matchArray[(($1*5+3))]} - ${matchArray[(($1*5+4))]} ${team2} | ${dateNotUTC}"
	printf "%s\n" ""
}

# Get team color code from colors.data
get_team_color(){
#RedSox/WhiteSox and nba/nhl Kings
local teamArray=( $1 )
local teamColor=${teamArray[-1],,}
case "$teamColor" in
	"76ers")
	echo "seventysixers"
	;;
	"49ers")
	echo "fourtyniners"
	;;
	"sox")
	if [ ${teamArray[-2],,} = "red" ]
	then
		echo "redsox"
	else
		echo "sox"
	fi
	;;
	"jets")
	if [ ${teamArray[-2],,} = "york" ]
	then
		echo "nfljets"
	else
		echo "jets"
	fi
	;;
	"kings")
	if [ ${teamArray[-2],,} = "angeles" ]
	then
		echo "nhlkings"
	else
		echo "kings"
	fi
	;;
	*)
	echo "$teamColor"
	;;
esac
}

# Main with subcommand checker
# Help / Empty
# Valid subCommand (Check TBA)
# Bad subCommand (TBA)
main(){
source colors.data
source emoji.data
source football.data
if [ -f .env ]; then source .env; fi
local subCommand=$1
case "${subCommand}" in
	"help" | "")
		sub_help
		;;
	"planning")
		shift
		sub_"${subCommand}" "$@"
		;;
	"results")
		shift
		sub_"${subCommand}" "$@"
		;;
	*)
		printf "%s%s\n\n" ${subCommand} " is an invalid parameter, please refer to the following help"
		sub_help
		;;
esac
}

main "$@"